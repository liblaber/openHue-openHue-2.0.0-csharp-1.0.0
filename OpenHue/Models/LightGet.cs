// This file was generated by liblab | https://liblab.com/

using System.Text.Json.Serialization;
using OpenHue.Json;

namespace OpenHue.Models;

public record LightGet(
    /// <value>Type of the supported resources</value>
    [property:
        JsonPropertyName("type"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        string? Type_ = null,
    /// <value>Unique identifier representing a specific resource instance</value>
    [property: JsonPropertyName("id"), JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        string? Id = null,
    /// <value>Clip v1 resource identifier</value>
    [property:
        JsonPropertyName("id_v1"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        string? IdV1 = null,
    [property:
        JsonPropertyName("owner"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        ResourceIdentifier? Owner = null,
    /// <value>Deprecated, use metadata on device level</value>
    [property:
        JsonPropertyName("metadata"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetMetadata? Metadata = null,
    [property: JsonPropertyName("on"), JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        On? On = null,
    [property:
        JsonPropertyName("dimming"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetDimming? Dimming = null,
    [property:
        JsonPropertyName("color_temperature"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetColorTemperature? ColorTemperature = null,
    [property:
        JsonPropertyName("color"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetColor? Color = null,
    [property:
        JsonPropertyName("dynamics"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetDynamics? Dynamics = null,
    /// <value>TODO</value>
    [property:
        JsonPropertyName("alert"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        object? Alert = null,
    /// <value>Feature containing signaling properties.</value>
    [property:
        JsonPropertyName("signaling"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetSignaling? Signaling = null,
    [property:
        JsonPropertyName("mode"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetMode? Mode = null,
    [property:
        JsonPropertyName("gradient"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetGradient? Gradient = null,
    /// <value>Basic feature containing effect properties.</value>
    [property:
        JsonPropertyName("effects"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetEffects? Effects = null,
    /// <value>Basic feature containing timed effect properties.</value>
    [property:
        JsonPropertyName("timed_effects"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetTimedEffects? TimedEffects = null,
    /// <value>Feature containing properties to configure powerup behaviour of a lightsource.</value>
    [property:
        JsonPropertyName("powerup"),
        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
    ]
        LightGet.LightGetPowerup? Powerup = null
)
{
    /// <summary>Deprecated, use metadata on device level</summary>
    public record LightGetMetadata(
        /// <value>Human readable name of a resource</value>
        [property:
            JsonPropertyName("name"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            string? Name = null,
        /// <value>Light archetype</value>
        [property:
            JsonPropertyName("archetype"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightArchetype? Archetype = null,
        /// <value>A fixed mired value of the white lamp</value>
        [property:
            JsonPropertyName("fixed_mired"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            long? FixedMired = null
    );

    public record LightGetDimming(
        /// <value>Brightness percentage. value cannot be 0, writing 0 changes it to lowest possible brightness</value>
        [property:
            JsonPropertyName("brightness"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            double? Brightness = null,
        /// <value>Percentage of the maximum lumen the device outputs on minimum brightness</value>
        [property:
            JsonPropertyName("min_dim_level"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            double? MinDimLevel = null
    );

    public record LightGetColorTemperature(
        /// <value>color temperature in mirek or null when the light color is not in the ct spectrum</value>
        [property:
            JsonPropertyName("mirek"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            long? Mirek = null,
        /// <value>Indication whether the value presented in mirek is valid</value>
        [property:
            JsonPropertyName("mirek_valid"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            bool? MirekValid = null,
        [property:
            JsonPropertyName("mirek_schema"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightGetColorTemperature.MirekSchema? MirekSchema_ = null
    )
    {
        public record MirekSchema(
            /// <value>minimum color temperature this light supports</value>
            [property:
                JsonPropertyName("mirek_minimum"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                long? MirekMinimum = null,
            /// <value>maximum color temperature this light supports</value>
            [property:
                JsonPropertyName("mirek_maximum"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                long? MirekMaximum = null
        );
    }

    public record LightGetColor(
        /// <value>CIE XY gamut position</value>
        [property:
            JsonPropertyName("xy"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            GamutPosition? Xy = null,
        /// <value>Color gamut of color bulb. Some bulbs do not properly return the Gamut information. In this case this is not present.</value>
        [property:
            JsonPropertyName("gamut"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightGetColor.Gamut? Gamut_ = null,
        /// <value>The gammut types supported by hue – A Gamut of early Philips color-only products – B Limited gamut of first Hue color products – C Richer color gamut of Hue white and color ambiance products – other Color gamut of non-hue products with non-hue gamuts resp w/o gamut</value>
        [property:
            JsonPropertyName("gamut_type"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightGetColor.GamutType? GamutType_ = null
    )
    {
        /// <summary>Color gamut of color bulb. Some bulbs do not properly return the Gamut information. In this case this is not present.</summary>
        public record Gamut(
            /// <value>CIE XY gamut position</value>
            [property:
                JsonPropertyName("red"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                GamutPosition? Red = null,
            /// <value>CIE XY gamut position</value>
            [property:
                JsonPropertyName("green"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                GamutPosition? Green = null,
            /// <value>CIE XY gamut position</value>
            [property:
                JsonPropertyName("blue"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                GamutPosition? Blue = null
        );

        /// <summary>The gammut types supported by hue – A Gamut of early Philips color-only products – B Limited gamut of first Hue color products – C Richer color gamut of Hue white and color ambiance products – other Color gamut of non-hue products with non-hue gamuts resp w/o gamut</summary>
        public record GamutType : ValueEnum<string>
        {
            internal GamutType(string value)
                : base(value) { }

            public GamutType()
                : base("A") { }

            public static GamutType A = new("A");
            public static GamutType B = new("B");
            public static GamutType C = new("C");
            public static GamutType Other = new("other");
        }
    }

    public record LightGetDynamics(
        /// <value>Current status of the lamp with dynamics.</value>
        [property:
            JsonPropertyName("status"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            SupportedDynamicStatus? Status = null,
        /// <value>Statuses in which a lamp could be when playing dynamics.</value>
        [property:
            JsonPropertyName("status_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedDynamicStatus>? StatusValues = null,
        /// <value>speed of dynamic palette or effect. The speed is valid for the dynamic palette if the status is dynamic_palette or for the corresponding effect listed in status. In case of status none, the speed is not valid</value>
        [property:
            JsonPropertyName("speed"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            double? Speed = null,
        /// <value>Indicates whether the value presented in speed is valid</value>
        [property:
            JsonPropertyName("speed_valid"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            bool? SpeedValid = null
    );

    /// <summary>Feature containing signaling properties.</summary>
    public record LightGetSignaling(
        [property:
            JsonPropertyName("signal_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedSignals>? SignalValues = null,
        /// <value>Timestamp indicating when the active signal is expected to end. Value is not set if there is no_signal</value>
        [property:
            JsonPropertyName("estimated_end"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            long? EstimatedEnd = null,
        /// <value>Colors that were provided for the active effect.</value>
        [property:
            JsonPropertyName("colors"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<Color>? Colors = null
    );

    public record LightGetMode : ValueEnum<string>
    {
        internal LightGetMode(string value)
            : base(value) { }

        public LightGetMode()
            : base("normal") { }

        public static LightGetMode Normal = new("normal");
        public static LightGetMode Streaming = new("streaming");
    }

    public record LightGetGradient(
        /// <value>Collection of gradients points. For control of the gradient points through a PUT a minimum of 2 points need to be provided.</value>
        [property:
            JsonPropertyName("points"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<Color>? Points = null,
        /// <value>Mode in which the points are currently being deployed. If not provided during PUT/POST it will be defaulted to interpolated_palette</value>
        [property:
            JsonPropertyName("mode"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            SupportedGradientMode? Mode = null,
        /// <value>Number of color points that gradient lamp is capable of showing with gradience.</value>
        [property:
            JsonPropertyName("points_capable"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            long? PointsCapable = null,
        /// <value>Modes a gradient device can deploy the gradient palette of colors</value>
        [property:
            JsonPropertyName("mode_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedGradientMode>? ModeValues = null,
        /// <value>Number of pixels in the device</value>
        [property:
            JsonPropertyName("pixel_count"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            long? PixelCount = null
    );

    /// <summary>Basic feature containing effect properties.</summary>
    public record LightGetEffects(
        [property:
            JsonPropertyName("status"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            SupportedEffects? Status = null,
        /// <value>Possible status values in which a light could be when playing an effect.</value>
        [property:
            JsonPropertyName("status_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedEffects>? StatusValues = null,
        [property:
            JsonPropertyName("effect"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            SupportedEffects? Effect = null,
        /// <value>Possible status values in which a light could be when playing an effect.</value>
        [property:
            JsonPropertyName("effect_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedEffects>? EffectValues = null
    );

    /// <summary>Basic feature containing timed effect properties.</summary>
    public record LightGetTimedEffects(
        /// <value>Current status values the light is in regarding timed effects</value>
        [property:
            JsonPropertyName("effect"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            SupportedTimedEffects? Effect = null,
        /// <value>Possible timed effect values you can set in a light</value>
        [property:
            JsonPropertyName("effect_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedTimedEffects>? EffectValues = null,
        /// <value>Current status values the light is in regarding timed effects</value>
        [property:
            JsonPropertyName("status"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            SupportedTimedEffects? Status = null,
        /// <value>Possible status values in which a light could be when playing a timed effect.</value>
        [property:
            JsonPropertyName("status_values"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            List<SupportedTimedEffects>? StatusValues = null,
        /// <value>Duration is mandatory when timed effect is set except for no_effect. Resolution decreases for a larger duration. e.g Effects with duration smaller than a minute will be rounded to a resolution of 1s, while effects with duration larger than an hour will be arounded up to a resolution of 300s. Duration has a max of 21600000 ms.</value>
        [property:
            JsonPropertyName("duration"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            long? Duration = null
    );

    /// <summary>Feature containing properties to configure powerup behaviour of a lightsource.</summary>
    public record LightGetPowerup(
        /// <value>When setting the custom preset the additional properties can be set. For all other presets, no other properties can be included.</value>
        [property:
            JsonPropertyName("preset"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightGetPowerup.PowerupPreset1? Preset = null,
        /// <value>Indicates if the shown values have been configured in the lightsource.</value>
        [property:
            JsonPropertyName("configured"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            bool? Configured = null,
        [property:
            JsonPropertyName("on"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightGetPowerup.PowerupOn1? On = null,
        [property:
            JsonPropertyName("dimming"),
            JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
        ]
            LightGetPowerup.PowerupDimming1? Dimming = null
    )
    {
        /// <summary>When setting the custom preset the additional properties can be set. For all other presets, no other properties can be included.</summary>
        public record PowerupPreset1 : ValueEnum<string>
        {
            internal PowerupPreset1(string value)
                : base(value) { }

            public PowerupPreset1()
                : base("safety") { }

            public static PowerupPreset1 Safety = new("safety");
            public static PowerupPreset1 Powerfail = new("powerfail");
            public static PowerupPreset1 LastOnState = new("last_on_state");
            public static PowerupPreset1 Custom = new("custom");
        }

        public record PowerupOn1(
            /// <value>
            /// State to activate after powerup.
            /// On will use the value specified in the “on” property.
            /// When setting mode “on”, the on property must be included.
            /// Toggle will alternate between on and off on each subsequent power toggle.
            /// Previous will return to the state it was in before powering off.
            /// </value>
            [property:
                JsonPropertyName("mode"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                PowerupOn1.OnMode1? Mode = null,
            [property:
                JsonPropertyName("on"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                On? On = null
        )
        {
            /// <summary>
            /// State to activate after powerup.
            /// On will use the value specified in the “on” property.
            /// When setting mode “on”, the on property must be included.
            /// Toggle will alternate between on and off on each subsequent power toggle.
            /// Previous will return to the state it was in before powering off.
            /// </summary>
            public record OnMode1 : ValueEnum<string>
            {
                internal OnMode1(string value)
                    : base(value) { }

                public OnMode1()
                    : base("on") { }

                public static OnMode1 On = new("on");
                public static OnMode1 Toggle = new("toggle");
                public static OnMode1 Previous = new("previous");
            }
        }

        public record PowerupDimming1(
            /// <value>
            /// Dimming will set the brightness to the specified value after power up.
            /// When setting mode “dimming”, the dimming property must be included.
            /// Previous will set brightness to the state it was in before powering off.
            /// </value>
            [property:
                JsonPropertyName("mode"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                PowerupDimming1.DimmingMode1? Mode = null,
            [property:
                JsonPropertyName("dimming"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                Dimming? Dimming = null,
            [property:
                JsonPropertyName("color"),
                JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
            ]
                PowerupDimming1.DimmingColor1? Color = null
        )
        {
            /// <summary>
            /// Dimming will set the brightness to the specified value after power up.
            /// When setting mode “dimming”, the dimming property must be included.
            /// Previous will set brightness to the state it was in before powering off.
            /// </summary>
            public record DimmingMode1 : ValueEnum<string>
            {
                internal DimmingMode1(string value)
                    : base(value) { }

                public DimmingMode1()
                    : base("dimming") { }

                public static DimmingMode1 Dimming = new("dimming");
                public static DimmingMode1 Previous = new("previous");
            }

            public record DimmingColor1(
                /// <value>State to activate after powerup. Availability of “color_temperature” and “color” modes depend on the capabilities of the lamp. Colortemperature will set the colortemperature to the specified value after power up. When setting color_temperature, the color_temperature property must be included Color will set the color tot he specified value after power up. When setting color mode, the color property must be included Previous will set color to the state it was in before powering off.</value>
                [property:
                    JsonPropertyName("mode"),
                    JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
                ]
                    DimmingColor1.ColorMode1? Mode = null,
                [property:
                    JsonPropertyName("color_temperature"),
                    JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
                ]
                    DimmingColor1.ColorColorTemperature1? ColorTemperature = null
            )
            {
                /// <summary>State to activate after powerup. Availability of “color_temperature” and “color” modes depend on the capabilities of the lamp. Colortemperature will set the colortemperature to the specified value after power up. When setting color_temperature, the color_temperature property must be included Color will set the color tot he specified value after power up. When setting color mode, the color property must be included Previous will set color to the state it was in before powering off.</summary>
                public record ColorMode1 : ValueEnum<string>
                {
                    internal ColorMode1(string value)
                        : base(value) { }

                    public ColorMode1()
                        : base("color_temperature") { }

                    public static ColorMode1 ColorTemperature = new("color_temperature");
                    public static ColorMode1 Color = new("color");
                    public static ColorMode1 Previous = new("previous");
                }

                public record ColorColorTemperature1(
                    /// <value>color temperature in mirek or null when the light color is not in the ct spectrum</value>
                    [property:
                        JsonPropertyName("mirek"),
                        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
                    ]
                        long? Mirek = null,
                    [property:
                        JsonPropertyName("color"),
                        JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)
                    ]
                        Color? Color = null
                );
            }
        }
    }
}
